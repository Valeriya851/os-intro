---
# Front matter
lang: ru-RU
title: "Отчет по лабораторной работе №15"

author: "Тулеева Валерия, НБИбд-01-20"

# Formatting
toc_depth: 2
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---
РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ

Факультет физико-математических и естественных наук
Кафедра прикладной информатики и теории вероятностей







# ***Именованные каналы***

# **Оглавление:**

1.	Введение:
  a) Цель работы
2.	Описание результатов выполнения задания;
3.	Библиография;
4.	Вывод;
5.	Контрольные вопросы.

























# **Введение:**

Одним из видов взаимодействия между процессами в операционных системах является обмен сообщениями. Под сообщением понимается последовательность байтов, передаваемая от одного процесса другому.

В операционных системах типа UNIX есть 3 вида межпроцессорных взаимодействий: общеюниксные (именованные каналы, сигналы), System V Interface Definition (SVID — разделяемая память, очередь сообщений, семафоры) и BSD (со- кеты). [Источник](https://esystem.rudn.ru/pluginfile.php/1142529/mod_resource/content/1/013-ipc-fifo.pdf)

Для передачи данных между неродственными процессами можно использовать механизм именованных каналов (named pipes). Данные передаются по принципу FIFO (First In First Out) (первым записан — первым прочитан), поэтому они называются также FIFO pipes или просто FIFO. Именованные каналы отличаются от неименованных наличием идентификатора канала, который представлен как специальный файл (соответственно имя именованного канала — это имя файла). По-]скольку файл находится на локальной файловой системе, данное IPC используется внутри одной системы.

Файлы именованных каналов создаются функцией mkfifo(3).

#include <sys/types.h>

#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);

Первый параметр — имя файла, идентифицирующего канал, второй параметр — маска прав доступа к файлу.

Каналы представляют собой простое и удобное средство передачи данных, которое, однако, подходит не во всех ситуациях. Например, с помощью каналов довольно трудно организовать обмен асинхронными сообщениями между процессами.
[Источник](https://esystem.rudn.ru/pluginfile.php/1142529/mod_resource/content/1/013-ipc-fifo.pdf)


# **Цель работы:**

Приобретение практических навыков работы с именованными каналами.


# **Описание результатов выполнения задания:**


1. Cоздала файлы:

```touch Makefile``` *(рис 1.1)*:

   ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/4.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566264-23f5e500-ca3f-11eb-81b5-5633eab6892e.png))
   
*Рис 1.1. Makefile*

```touch server.c``` *(рис 1.2)*:

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/3.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566227-1b9daa00-ca3f-11eb-958a-d84ec7d59af5.png))

*Рис 1.2. server.c*

```touch client.c``` *(рис 1.3)*:

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/2.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566187-12144200-ca3f-11eb-82ed-62382ed028bf.png))

*Рис 1.3. client.c*

```touch common.h``` *(рис 1.4)*:

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/1.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566139-0759ad00-ca3f-11eb-84a1-c3548c8014db.png))

*Рис 1.4. common.h*


2.	Далее я выполнила следующее задание:

Задание:

Изучите приведённые в тексте программы server.c и client.c. Взяв данные примеры за образец, напишите аналогичные программы, внеся следующие изменения:

1. Работает не 1 клиент, а несколько (например, два).

2. Клиенты передают текущее время с некоторой периодичностью (например, раз в пять секунд). Используйте функцию sleep() для приостановки работы клиента.

3. Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени работы
сервера. Что будет в случае, если сервер завершит работу, не закрыв канал?
 
Измененный Makefile *(рис 2.1)*:
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/5.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566309-307a3d80-ca3f-11eb-8b77-52552ffd2e22.png))
 
*Рис 2.1. Makefile*

Измененный server.c *(рис 2.2)*:
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/7.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566389-47209480-ca3f-11eb-8b8a-1bfcfc7aaaee.png))
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/8.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566436-569fdd80-ca3f-11eb-8cdc-a9e002951c76.png))
 
*Рис 2.2. server.c*


Измененный client.c *(рис 2.3)*:
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/6.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566354-3bcd6900-ca3f-11eb-99af-3749c41dc719.png))
 
*Рис 2.3. client.c*


Измененный common.h *(рис 2.4)*:
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/9.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566481-615a7280-ca3f-11eb-8a20-4c22e2d16c46.png))
 
*Рис 2.4. coomon.h*

3.	Запуск: *(рис 3.1)*

Можно запустить или с помощью Makefile:

Ввести ```make```

Или вот так:

```gcc server.c -o server``` и ```gcc client.c -o client```

```./server``` и ```./client```


![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab15/Screenshot/запуск.png?raw=true![image](https://user-images.githubusercontent.com/83212205/121566520-6ae3da80-ca3f-11eb-88c8-329d0fc5bb8c.png))

*Рис 3.1. Запуск*

 

# **Библиография:**

1. [Источник](https://esystem.rudn.ru/pluginfile.php/1142529/mod_resource/content/1/013-ipc-fifo.pdf)


# **Вывод:**

В данной лабораторной работе, я приобрела практические навыки работы с именованными каналами.



# **Контрольные вопросы (лабораторная работа №15)**

*1. В чем ключевое отличие именованных каналов от неименованных?* 

Именованные каналы отличаются от неименованных наличием идентификатора канала, который представлен как специальный файл (соответственно имя именованного канала — это имя файла).

*2.	Возможно ли создание неименованного канала из командной строки?*

Неименованные каналы подобны именованным, но они в файловой системе не существуют. Они не имеют путевых имен, ассоциированных с ними, и все они и их следы исчезают после того, как последний файловый дескриптор, ссылающийся на них, закрывается. Они почти исключительно используются для межпроцессных коммуникаций между дочерними и родительскими процессами либо между родственными процессами.

Оболочки применяют неименованные каналы для выполнения команд вроде ls | head. Процесс ls пишет в тот канал, из которого head читает свой ввод, выдавая ожидаемый пользователем результат.

Создание неименованного канала выполняется по двум файловым дескрипторам, один из которых доступен только для чтения, а второй — только для записи.


*3.	Возможно ли создание именованного канала из командной строки?*

Файлы именованных каналов создаются функцией mkfifo(3). 

```#include <sys/types.h>```

```#include <sys/stat.h>```

```int mkfifo(const char *pathname, mode_t mode);```

Первый параметр — имя файла, идентифицирующего канал, второй параметр — маска прав доступа к файлу.

Вы можете создавать именованные каналы из командной строки и внутри программы.


*4.	Опишите функцию языка С, создающую неименованный канал.* 

Неименованный канал создается вызовом pipe, который заносит в массив int [2] два дескриптора открытых файлов. fd[0] – открыт на чтение, fd[1] – на запись (вспомните STDIN == 0, STDOUT == 1). Канал уничтожается, когда будут закрыты все файловые дескрипторы ссылающиеся на него.

В рамках одного процесса pipe смысла не имеет, передать информацию о нем в произвольный процесс нельзя (имени нет, а номера файловых дескрипторов в каждом процессе свои). Единственный способ использовать pipe – унаследовать дескрипторы при вызове fork (и последующем exec). После вызова fork канал окажется открытым на чтение и запись в родительском и дочернем процессе. Т.е. теперь на него будут ссылаться 4 дескриптора. Теперь надо определиться с направлением передачи данных – если надо передавать данные от родителя к потомку, то родитель закрывает дескриптор на чтение, а потомок - дескриптор на запись.

```int fd[2];```

```char c;```

```pipe(fd);```

```if( fork() ) { //родитель```

    ```close(fd[0]);```
    
    ```c=0;```
    
    ```while(write(fd[1],&c,1) >0)  {```
    
        ```c++;```
        
    ```}```
    
```} else { //дочерний процесс```

    ```dup2(fd[0],0); //подменили STDIN```
    
    ```close(fd[0]);```
    
    ```close(fd[1]);```
    
    ```execl("prog","prog",NULL); //запустили новую программу для которой STDIN = pipe```
    
```}```

Оставлять оба дескриптора незакрытыми плохо по двум причинам:

Родитель после записи не может узнать считал ли дочерний процесс данные, а если считал то сколько. Соответственно, если родитель попробует читать из pipe, то, вполне вероятно, он считает часть собственных данных, которые станут недоступными для потомка.

Если один из процессов завершился или закрыл свои дескрипторы, то второй этого не заметит, так как pipe на его стороне по-прежнему открыт на чтение и на запись.

Если надо организовать двунаправленную передачу данных, то можно создать два pipe.


 
*5. Опишите функцию языка С, создающую именованный канал.* 

Именованный канал FIFO доступен как объект в файловой системе. При этом, до открытия объекта FIFO на чтение, собственно коммуникационного объекта не создаётся. После открытия открытия объекта FIFO в одном процессе на чтение, а в другом на запись, возникает ситуация полностью эквивалентная использованию неименованного канала.

Объект FIFO в файловой системе создаётся вызовом функции int mkfifo(const char *pathname, mode_t mode);,

Основное отличие между pipe и FIFO - то, что pipe могут совместно использовать только процессы находящиеся в отношении родительский-дочерний, а FIFO может использовать любая пара процессов.



*6. Что будет в случае прочтения из fifo меньшего числа байтов, чем находится в канале? Большего числа байтов?* 
 
При чтении меньшего числа байтов, чем находится в канале или FIFO, возвращается требуемое число байтов, остаток сохраняется для последующих чтений.

При чтении большего числа байтов, чем находится в канале или FIFO, возвращается доступное число байтов.

*7.	Аналогично, что будет в случае записи в fifo меньшего числа байтов, чем позволяет буфер? Большего числа байтов?* 

Мы можем писать в канал до тех пор пока есть место в буфере, если место в буфере кончится – процесс будет заблокирован на записи. Можем читать из канала пока есть данные в буфере, если данных нет – процесс будет заблокирован на чтении. 

*8.	Могут ли два и более процессов читать или записывать в канал?*

С точки зрения процессов, канал выглядит как пара открытых файловых дескрипторов – один на чтение и один на запись (можно больше, но неудобно).

*9. Опишите функцию write (тип возвращаемого значения, аргументы и логику работы). Что означает 1 (единица) в вызове этой функции в программе server.c
(строка 42)?*

Функция write() является частью UNIX-подобной системы ввода/вывода и не определена стандартом ANSI С. Функция write() переписывает count байт из буфера, на который указывает bufy в файл, соответствующий дескриптору файла handle. Указателю положения в файле дается приращение на количество записанных байт.

Возвращаемым значением является количество действительно записанных байт. Если встретится ошибка, это количество может быть меньше, чем count. В случае ошибки возвращается —1.

Стандартный поток вывода имеет идентификатор 1.


*10. Опишите функцию strerror.*

Строковая функция strerror - функция языков C/C++, транслирующая код ошибки, который обычно хранится в глобальной переменной errno, в сообщение об ошибке, понятном человеку.

