---
# Front matter
lang: ru-RU
title: "Отчет по лабораторной работе №11"

author: "Тулеева Валерия, НБИбд-01-20"

# Formatting
toc_depth: 2
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---
РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ

Факультет физико-математических и естественных наук
Кафедра прикладной информатики и теории вероятностей







# ***Программирование в командном процессоре ОС UNIX. Командные файлы***

# **Оглавление:**

1.	Введение:
  a) Цель работы
2.	Описание результатов выполнения задания;
3.	Вывод;
4.	Библиография;
5.	Контрольные вопросы.

























# **Введение:**

*Командный процессор* (командная оболочка, интерпретатор команд shell) — это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. В операционных системах типа UNIX/Linux наиболее часто используются следующие реализации командных оболочек:

– *оболочка Борна* (Bourne shell или sh) — стандартная командная оболочка UNIX/Linux, содержащая базовый, но при этом полный набор функций;

– *С-оболочка* (или csh) — надстройка на оболочкой Борна, использующая С- подобный синтаксис команд с возможностью сохранения истории выполнения команд;

– *оболочка Корна *(или ksh) — напоминает оболочку С, но операторы управления программой совместимы с операторами оболочки Борна;

– *BASH* — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software Foundation).

*POSIX* (Portable Operating System Interface for Computer Environments) — набор стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ. [Источник](https://esystem.rudn.ru/pluginfile.php/1142517/mod_resource/content/2/008-lab_shell_prog_1.pdf)


# **Цель работы:**

Изучить основы программирования в оболочке ОС UNIX/Linux. Научиться писать небольшие командные файлы.



# **Описание результатов выполнения задания:**


1.  Изучила информацию о ```zip```, ```tar```, ```bzip2``` , вызвав в командной строке ```man ...```*(рис 1.1 и 1.2, 1.3, 1.4, 1.5, 1.6)*:


 ```man zip```; *(рис 1.1 и рис 1.2)*
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/1.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545233-66b78c00-bdb4-11eb-8fe7-cd9772f49687.png))
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/2.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545255-71722100-bdb4-11eb-978b-4bcbd847f54a.png))
 
 *Рис 1.1 и 1.2. Команда man zip*
 
 
 ```man bzip2```; *(рис 1.3 и рис 1.4)*
 

 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/3.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545313-7e8f1000-bdb4-11eb-9ab0-e270ae44cade.png))
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/4.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545342-88b10e80-bdb4-11eb-94d4-b4469ea22286.png))
 
 *Рис 1.3 и 1.4. Команда man bzip2*
 
 
 ```man tar```; *(рис 1.5 и рис 1.6 )*

 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/5.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545384-936ba380-bdb4-11eb-804f-1946389b376d.png))
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/6.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545422-9d8da200-bdb4-11eb-9223-f4bf43083068.png))
 
 *Рис 1.5 и 1.6. Команда man tar*
 

2.	 Создала файл ```lab11.txt``` *(рис 2.1)*:

```touch lab11.txt```
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/7.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545469-aa11fa80-bdb4-11eb-9d05-27949687aa34.png))
 
*Рис 2.1. Создание файла ```lab11.txt```*



3.	Написала скрипт, который при запуске будет делать резервную копию самого себя (то есть файла, в котором содержится его исходный код) в другую директорию backup в домашнем каталоге. При этом файл архивируется архиватором tar *(рис 3.1)* :

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/8.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545500-b39b6280-bdb4-11eb-8c2d-c80da856f2d7.png))

*Рис 3.1. Написала скрипт*

**Скрипт**

 #!/bin/bash                                                    (*Командная оболочка Bash*)
 
cp lab11.txt backup                                             (*Копирование файла с кодом в директорию*)

echo "Файл с исходным кодом скопирован в директорию backup".    (*Вывод на экран строки*)

tar --totals -cvf archive.tar lab11.txt                         (*С помощью этой команды создается архив*) [Источник](https://losst.ru/komanda-tar-v-linux)

echo "Архивация файла"                                          (*Вывод на экран строки*)


4.  Сделала файл исполняемым *(рис 4.1)*: `

```chmod ugo+x lab11.txt```

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/9.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545559-c6159c00-bdb4-11eb-8ece-dd2409bed507.png))

*Рис 4.1. Исполняемый файл*


5.	Запуск скрипта: *(рис 5.1)*
 
 ```./lab11.txt```
 
 Правильность выполнения:
 
 ```ls```;
 
 ```ls backup```
 
![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/10.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545600-d0d03100-bdb4-11eb-8cb9-50a9dfbe5df5.png))

*Рис 5.1. Запуск и проверила правильность выполнения*



6.	Создала файл ```lab.txt``` *(рис 6.1)*:

```touch lab.txt```
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/11.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545797-07a64700-bdb5-11eb-9be7-8d7e8c5964ce.png))
 
*Рис 6.1. Создание файла ```lab.txt```*


7.	Написала пример командного файла, обрабатывающего любое произвольное число аргументов командной строки, в том числе превышающее десять. Скрипт может последовательно распечатывать значения всех переданных аргументов: *(рис 7.1)*

 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/12.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545835-112faf00-bdb5-11eb-8c09-ff615cde889a.png))
 
*Рис 7.1. Написанный скрипт*

**Скрипт:**

#!/bin/bash                          (*Командная оболочка Bash*)

echo $1

echo $2

echo $3                              (*Позиционные аргументы сценария*)

echo $4

echo $5

echo $6                 

echo $7

echo $8

echo $9

echo ${10}

echo ${11}

8.	Сделала файл исполняемым *(рис 8.1)*: `

```chmod ugo+x lab.txt```

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/13.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545916-24427f00-bdb5-11eb-9f99-c737de13e37c.png))

*Рис 8.1. Исполняемый файл*

9. Запуск скрипта: *(рис 9.1 и 9.2)*
 
 ```./lab.txt```
 
 Несколько переменных:
 
![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/14.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119545987-3c1a0300-bdb5-11eb-92f8-5f01b808b11b.png))

*Рис 9.1. Запуск*

11 переменных:

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/15.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546033-450ad480-bdb5-11eb-835e-e69f47fab1c2.png))

*Рис 9.2. Запуск*

10.	Создала файл ```lb.txt``` *(рис 10.1)*:

```touch lb.txt```
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/16.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546076-5227c380-bdb5-11eb-9bf0-10b81678898e.png))
 
*Рис 10.1. Создание файла ```lb.txt```*

11.	Написала командный файл — аналог команды ```ls``` *(рис 11.1)*:

 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/17.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546185-75eb0980-bdb5-11eb-9f6e-cc271a95bc2c.png))
 
*Рис 11.1. Создание скрипта*

**Скрипт:**

#!/bin/bash                       (*Командная оболочка Bash*)

for file in *

do                                (*Делается*)

echo -n $file:""

pwd 

done                              (*Сделано*)


12.	Сделала файл исполняемым *(рис 12.1)*: `

```chmod ugo+x lb.txt```

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/18.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546239-8602e900-bdb5-11eb-97f9-007fea996309.png))

*Рис 12.1. Исполняемый файл*

13. Запуск скрипта: *(рис 13.1)*
 
 ```./lb.txt```
 
 Ввела ```/home``` 
 
![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/20.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546323-9915b900-bdb5-11eb-8270-85e1d2a8ed56.png))

*Рис 13.1. Запуск*


14. Создала файл ```l.txt``` *(рис 14.1)*:

```touch l.txt```
 
 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/21.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546362-a3d04e00-bdb5-11eb-9123-11e7bc38e57d.png))
 
*Рис 14.1. Создание файла ```l.txt```*

15. Написала командный файл, который получает в качестве аргумента командной строки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет количество таких файлов в указанной директории. Путь к директории также передаётся в виде аргумента командной строки.

 ![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/22.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546388-ae8ae300-bdb5-11eb-9bcc-47b139fae3b8.png))
 
*Рис 15.1. Создание скрипта*

**Скрипт:**

#!/bin/bash                            (*Командная оболочка Bash*)

echo $1                                (*Позиционные аргументы сценария*)

echo $2 

find $2 -name "*$1" -print             (*поиск файла с определенным файлом*)

tree -P "*$1" --prune $2               (*Выводит информацию, считает сколько файлов и директорий есть с таким форматом*)[Источник](https://losst.ru/komanda-tree-linux)


16. 	Сделала файл исполняемым *(рис 16.1)*: `

```chmod ugo+x l.txt```

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/23.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546435-bd719580-bdb5-11eb-95f2-75c906e09187.png))

*Рис 16.1. Исполняемый файл*


17. Запуск скрипта: *(рис 17.1 и 17.2)*
 
 ```./lb.txt```
 
 Ввела ```.txt``` ```~```
 
![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/24.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546545-d67a4680-bdb5-11eb-80c2-cd3f960f5818.png))

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/25.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546627-ee51ca80-bdb5-11eb-8abe-5fe787925875.png))

*Рис 17.1. Запуск*

Ввела ```.pdf``` ```~```

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/27.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546677-ff9ad700-bdb5-11eb-8e11-34e2f43cc522.png))

![](https://github.com/Valeriya851/os-intro/blob/os-intro/Lab11/Screenshot/28.png?raw=true![image](https://user-images.githubusercontent.com/83212205/119546742-13ded400-bdb6-11eb-8a9e-483ded1c6eb0.png))

*Рис 17.2. Запуск*



# **Библиография:**

1. [Источник 1](https://esystem.rudn.ru/pluginfile.php/1142517/mod_resource/content/2/008-lab_shell_prog_1.pdf)
2. [Источник 2](https://losst.ru/komanda-tar-v-linux)
3. [Источник 3](https://losst.ru/komanda-tree-linux)



# **Вывод:**

В данной лабораторной работе, я изучила основы программирования в оболочке ОС UNIX/Linux. Научилась писать небольшие командные файлы.



# **Контрольные вопросы (лабораторная работа №11)**

*1. Объясните понятие командной оболочки. Приведите примеры командных оболочек. Чем они отличаются?* 

*Командный процессор* (командная оболочка, интерпретатор команд shell) — это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. В операционных системах типа UNIX/Linux наиболее часто используются следующие реализации командных оболочек:

– *оболочка Борна* (Bourne shell или sh) — стандартная командная оболочка UNIX/Linux, содержащая базовый, но при этом полный набор функций;

– *С-оболочка* (или csh) — надстройка на оболочкой Борна, использующая С- подобный синтаксис команд с возможностью сохранения истории выполнения команд;

– *оболочка Корна *(или ksh) — напоминает оболочку С, но операторы управления программой совместимы с операторами оболочки Борна;

– *BASH* — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software Foundation).

*2.	Что такое POSIX?*

*POSIX* (Portable Operating System Interface for Computer Environments) — набор стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ. 

*3.	Как определяются переменные и массивы в языке программирования bash?*

Командный процессор bash обеспечивает возможность использования перемен- ных типа строка символов. Имена переменных могут быть выбраны пользователем. Пользователь имеет возможность присвоить переменной значение некоторой стро- ки символов. 

Bash-массивы имеют только численные индексы, но они не обязательны к использованию, то есть вы не должны определять значения всех индексов в явном виде. Массив целиком может быть определен путем заключения записей в круглые скобки.

*4.	Каково назначение операторов let и read?* 

Оболочка bash поддерживает встроенные арифметические функции. Команда ```let``` является показателем того, что последующие аргументы представляют собой выражение, подлежащее вычислению. Простейшее выражение — это единичный терм (term), обычно целочисленный.

Команда let берет два операнда и присваивает их переменной. Положительным моментом команды let можно считать то, что для идентификации переменной ей не нужен знак доллара; вы можете писать команды типа let sum=x+7, и let будет искать переменную x и добавлять к ней 7.

read mon day trash

В переменные mon и day будут считаны соответствующие значения, введённые с клавиатуры.
 
*5. Какие арифметические операции можно применять в языке программирования bash?* 


!  !ехр  Если ехр равно 0, то возвращает 1; иначе 0

!=  ехр1 !=ехр2  Если ехр1 не равно ехр2, то возвращает 1; иначе 0

% ехр1%ехр2 Возвращает остаток от деления ехр1 на ехр2

%= var=%exp Присваивает остаток от деления var на ехр переменной var

& ехр1&ехр2 Возвращает побитовое AND выражений ехр1 и ехр2

&& ехр1&&ехр2 Если и ехр1 и ехр2 не равны нулю, то возвращает 1; иначе 0

&= var &= ехр Присваивает переменной var побитовое AND var и ехр

* ехр1 * ехр2 Умножает ехр1 на ехр2

*= var *= ехр Умножает ехр на значение переменной var и присваивает результат переменной var

+ ехр1 + ехр2 Складывает ехр1 и ехр2

+= var += ехр Складывает ехр со значением переменной var и результат присваивает переменной var

- -exp Операция отрицания exp (унарный минус)

- expl - exp2 Вычитает exp2 из exp1

-= var -= exp Вычитает exp из значения переменной var и присваивает результат переменной var

/ exp / exp2 Делит exp1 на exp2

/= var /= exp Делит значение переменной var на exp и присваивает результат переменной var

< expl < exp2 Если exp1 меньше, чем exp2, то возвращает 1, иначе возвращает 0


*6. Что означает операция (( )) ?* 
 
Подобно С оболочка bash может присваивать переменной любое значение, а произвольное выражение само имеет значение, которое может использоваться. При этом «ноль» воспринимается как «ложь», а любое другое значение выражения — как «истина». Для облегчения программирования можно записывать условия обо- лочки bash в двойные скобки — (( )).


*7.	Какие стандартные имена переменных Вам известны?* 

– HOME — имя домашнего каталога пользователя. Если команда cd вводится без аргументов, то происходит переход в каталог, указанный в этой переменной.

– IFS — последовательность символов, являющихся разделителями в командной строке, например, пробел, табуляция и перевод строки (new line).

– MAIL — командный процессор каждый раз перед выводом на экран промптера проверяет содержимое файла, имя которого указано в этой переменной, и если содержимое этого файла изменилось с момента последнего ввода из него, то перед тем как вывести на терминал промптер, командный процессор выводит на терминал сообщение You have mail (у Вас есть почта).

– TERM — тип используемого терминала.

– LOGNAME — содержит регистрационное имя пользователя, которое устанавливается автоматически при входе в систему.

*8.	Что такое метасимволы?*


Такие символы, как ' < > * ? | \ " &, являются метасимволами и имеют для командного процессора специальный смысл. Снятие специального смысла с метасимвола называется экранированием метасимвола. 

*9. Как экранировать метасимволы?*

Экранирование может быть осуществлено с помощью предшествующего метасимволу символа \, который, в свою очередь, является метасимволом.


*10. Как создавать и запускать командные файлы?*
 Последовательность команд может быть помещена в текстовый файл. Такой файл называется командным. Далее этот файл можно выполнить по команде:
 
 
bash командный_файл [аргументы]
Чтобы не вводить каждый раз последовательности символов bash, необходимоизменить код защиты этого командного файла, обеспечив доступ к этому файлу по выполнению. Это может быть сделано с помощью команды

chmod +x имя_файла

Теперь можно вызывать свой командный файл на выполнение, просто вводя его имя с терминала так, как-будто он является выполняемой программой. Командный процессор распознает, что в Вашем файле на самом деле хранится не выполняе- мая программа, а программа, написанная на языке программирования оболочки, и осуществит её интерпретацию.

*11. Как определяются функции в языке программирования bash?*

Группу команд можно объединить в функцию. Для этого существует ключевое слово function, после которого следует имя функции и список команд, заключён- ных в фигурные скобки. Удалить функцию можно с помощью команды unset c флагом -f.

*12. Каким образом можно выяснить, является файл каталогом или обычным файлом?*

Команды ОС UNIX возвращают код завершения, значение которого может быть использовано для принятия решения о дальнейших действиях. Команда test, например, создана специально для использования в командных файлах. Единственная функция этой команды заключается в выработке кода завершения. Так например, команда

test -f file

возвращает нулевой код завершения (истина), если файл file существует, и ненулевой код завершения (ложь) в противном случае:

– test s –— истина, если аргумент s имеет значение истина;
– test -f file — истина, если файл file существует;
– test -i file — истина, если файл file доступен по чтению;
– test -w file — истина, если файл file доступен по записи;
– test -e file — истина, если файл file — исполняемая программа; – test -d file — истина, если файл file является каталогом.

*13. Каково назначение команд set, typeset и unset?*

Для создания массива используется команда set с флагом -A. За флагом следует имя переменной, а затем список значений, разделённых пробелами.

Если использовать typeset -i для объявления и присвоения переменной, то при последующем её применении она станет целой. Также можно использовать ключевое слово integer (псевдоним для typeset -i) и объявлять таким образом переменные целыми. Выражения типа х=y+z будет восприниматься в это случае как арифметические.

Изъять переменную из программы можно с помощью команды unset.

Удалить функцию можно с помощью команды unset c флагом -f.

*14. Как передаются параметры в командные файлы?*

При вызове командного файла на выполнение параметры ему могут быть переданы точно таким же образом, как и выполняемой программе. С точки зрения командного файла эти параметры являются позиционными. Символ $ является метасимволом командного процессора. Он используется, в частности, для ссылки на параметры, точнее, для получения их значений в командном файле. В командный файл можно передать до девяти параметров. При использовании где-либо в командном файле комбинации символов $i, где 0 < i < 10, вместо неё будет осуществлена подстановка значения параметра с порядковым номером i, т.е. аргумента командного файла с порядковым номером i. Использование комбинации символов $0 приводит к подстановке вместо неё имени данного командного файла. Рассмотрим это на примере.
Пусть к командному файлу where имеется доступ по выполнению и этот командный файл содержит следующий конвейер:

who | grep $1.

Если Вы введёте с терминала команду where andy, то в случае, если пользователь, зарегистрированный в ОС UNIX под именем andy, в данный момент работает в ОС UNIX, то на терминал будет выведена строка, содержащая номер терминала, используемого указанным пользователем. Если же в данный момент этот пользователь не работает в ОС UNIX, то на терминал ничего не будет выведено.

*15. Назовите специальные переменные языка bash и их назначение.*

Вот ещё несколько специальных переменных, используемых в командных файлах:

– $* — отображается вся командная строка или параметры оболочки;

– $? — код завершения последней выполненной команды;

– $$ — уникальный идентификатор процесса, в рамках которого выполняется ко-
мандный процессор;

– $! — номер процесса, в рамках которого выполняется последняя вызванная на
выполнение в командном режиме команда;

– $- — значение флагов командного процессора;

– ${#*} — возвращает целое число — количество слов, которые были результатом
$*;

– ${#name} — возвращает целое значение длины строки в переменной name;

– ${name[n]} — обращение к n-му элементу массива;

– ${name[*]} — перечисляет все элементы массива, разделённые пробелом;

– ${name[@]} — то же самое, но позволяет учитывать символы пробелы в самих
переменных;

– ${name:-value} — если значение переменной name не определено, то оно будет
заменено на указанное value;

– ${name:value} — проверяется факт существования переменной;

– ${name=value} — если name не определено, то ему присваивается значение
value;

– ${name?value} — останавливает выполнение, если имя переменной не опреде-
лено, и выводит value как сообщение об ошибке;

– ${name+value} — это выражение работает противоположно ${name-value}.
Если переменная определена, то подставляется value;

– ${name#pattern} — представляет значение переменной name с удалённым са-
мым коротким левым образцом (pattern);

– ${#name[*]} и ${#name[@]} — эти выражения возвращают количество элемен-
тов в массиве name.
